
enum ActionConfigMemberType {
    ai
    manual
}

type ActionConfigurationMember {
    """
    Whether additional array entries are allowed
    """
    allowAdditionalArrayEntries: Boolean!

    """
    The manual value for the member
    """
    manual: ActionConfigurationMemberManual

    """
    The path to the value
    """
    path: [String!]!

    """
    The prompt for the member
    """
    prompt: ActionConfigurationMemberPrompt

    """
    The type of the member
    """
    type: ActionConfigMemberType!

    """
    The union type of the member
    """
    unionType: Int
}

"""
Custom scalar type for ActionConfigurationMember manual value
"""
scalar ActionConfigurationMemberManual

"""
Custom scalar type for ActionConfigurationMember prompt value
"""
scalar ActionConfigurationMemberPrompt

type ActionDetails implements Node {
    """
    The auth config of the action, null if no auth is required.
    """
    authConfig: AuthConfig
    dependencies: [String!]!

    """
    The description of a tool, to be shown in the frontend
    """
    description: String!

    """
    The display name of a tool, to be shown in the frontend.
    """
    displayName: String!
    dynamicLoaders: DynamicLoaders

    """
    Whether the action has side effects
    """
    hasSideEffects: Boolean!
    inputSchema: JSON

    """
    Whether the action is premium
    """
    isPremium: Boolean!

    """
    The key of the action.
    """
    key: String!
    nodeId: ID!

    """
    The observable channel of the action
    """
    observableChannel: ObservableChannelMetadata

    """
    The output properties of the action
    """
    outputProperties: [ActionProperty!]!
    outputSchema: JSON
    tool: LindyTool!

    """
    The display name of a tool, to be shown in the frontend.
    """
    toolDisplayName: String!
}

type ActionNode implements Node & StateGraphNode {
    """
    The action configuration of the action
    """
    actionConfiguration: [ActionConfigurationMember!]!

    """
    The action of the node
    """
    actionDefinition: StateGraphAction

    """
    The auth of the action
    """
    auth: Auth

    """
    The auth entries available for the action
    """
    authList: [Auth!]!

    """
    The user-defined display name of the node
    """
    displayName: String

    """
    The guidelines of the action
    """
    guidelines: String

    """
    The unique identifier for the node
    """
    id: ID!

    """
    The knowledge base sources of the action
    """
    knowledgeSources: [KnowledgeSource!]!

    """
    Whether the node is manually positioned
    """
    manuallyPositioned: Boolean!

    """
    The LLM model of the action
    """
    model: String!

    """
    The globally unique ID for the Action Node
    """
    nodeId: ID!

    """
    The occurrence of the action
    """
    occurrence: Int!

    """
    The position of the node
    """
    position: NodePosition!

    """
    Whether the action requires confirmation
    """
    requireConfirmation: AgentRequireConfirmation!

    """
    The stateful tool occurrence of the action
    """
    statefulToolOccurrence: Int

    """
    The type of the node
    """
    type: NodeType!
}

type ActionProperty {
    """
    The optional display name for the action property.
    """
    displayName: String

    """
    The type of the action property.
    """
    type: ActionPropertyType!

    """
    The value of the action property.
    """
    value: String!
}

enum ActionPropertyType {
    Array
    Boolean
    Integer
    Null
    Number
    Object
    String
    Unknown
}

"""
An Agent Definition is the same as a Lindy, it contains information about the agent's behavior
"""
type AgentDefinition implements Node {
    conversations(
        after: String
        before: String
        first: Int
        last: Int
    ): AgentDefinitionConversationsConnection!

    """
    The date the agent was created
    """
    createdAt: DateTime!

    """
    Whether the agent is enabled or not. If not enabled tasks will not be executed for this agent
    """
    enabled: Boolean!

    """
    Greeting message for a new conversation
    """
    greetingMessage: String!
    hasPremiumActions: Boolean!
    hasPremiumTriggers: Boolean!
    icon: AgentIcon
    id: ID!

    """
    General Guidelines of the Agent Definition
    """
    instructions: String!

    """
    Integrations that the agent is connected to
    """
    integrations: [Tool!]!

    """
    Whether the agent is marked as a favorite
    """
    isFavorite: Boolean!

    """
    Whether notifications for the agent are muted
    """
    isMuted: Boolean!
    lastRunAt: DateTime
    memories: [Memory!]!

    """
    Default model to use
    """
    model: String!

    """
    The name of the Agent Definition
    """
    name: String!

    """
    The globally unique ID for the Agent Definition
    """
    nodeId: ID!
    notificationsCount: Int!
    owner: Identity!

    """
    Default field for safe mode. when set all nodes created will have to ask for confirmation from the user unless user overrides them manually
    """
    shouldAskForConfirmation: Boolean!

    """
    This is the State Graph currently active on this Agent Definition.
    """
    stateGraph: StateGraph

    """
    This is the State Graph Test Run currently active on this Agent Definition, notice that the State Graph set on this run will, most of the time, be different from the currently active State Graph of the Agent.
    """
    stateGraphTestRun: StateGraphTestRun

    """
    The date the agent was last updated
    """
    updatedAt: DateTime!
}

type AgentDefinitionConversationsConnection {
    edges: [AgentDefinitionConversationsConnectionEdge]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type AgentDefinitionConversationsConnectionEdge {
    cursor: String!
    node: Conversation!
}

enum AgentDefinitionOrigin {
    CreateLindyModal
    Duplication
    InstallLindyAction
    Marketplace
    MarketplaceTemplatePack
    Occupation
    ShareLink
    SignUpTemplateIdUrlParameter
    UnknownTemplate
}

type AgentFolder {
    """
    The list of Agent Definitions inside this specific folder
    """
    agentDefinitions: [AgentDefinition!]!
    clientId: ID
    id: ID!

    """
    Whether the folder is expanded or not in the UI
    """
    isExpanded: Boolean!

    """
    The name of the folder
    """
    name: String!

    """
    This is the total count of notifications across all agents inside this folder
    """
    notificationsCount: Int!

    """
    This folder's parent folder's client ID. If it is `null` it means this is a root folder. The data structure is flattened, so this is not a recursive field. We use client ID instead of the folder's ID to prevent race conditions on folder creation since the is some latency in folder creation do to the required LLM call
    """
    parentClientId: ID
}

input AgentFolderMovableItemInput {
    agentDefinitionId: ID
    agentFolderClientId: ID
}

type AgentFolders {
    """
    The list of agent folders. This is a flattened data structure, allowing us to have a "infinite" hierarchy of folders. The root folders have a `null` parent ID.
    """
    folders: [AgentFolder!]!

    """
    This is the root "folder", which contains everything that is not inside any specific folder
    """
    root: AgentRootFolder!
}

type AgentIcon {
    color: AgentIconColor!
    name: AgentIconName!
}

enum AgentIconColor {
    Amber
    Blue
    DarkGrey
    Emerald
    Fuchsia
    Green
    Grey
    Indigo
    Lime
    Pink
    Purple
    Red
    Sky
    Slate
    Yellow
}

input AgentIconInput {
    color: AgentIconColor!
    name: AgentIconName!
}

enum AgentIconName {
    AgentIcon1
    AgentIcon2
    AgentIcon3
    AgentIcon4
    AiStarsSparklesIcon
    AiThreeStarsSparklesIcon
    AirplaneIcon
    ArAugmentedRealityCardBoxDVirtualRealityVrIcon
    ArAugmentedRealityDViewCubeIcon
    ArchiveBoxIcon
    ArchiveBoxInboxFileIcon
    ArrowRightCircleIcon
    AtIcon
    AudioMusicPlaylistMusicalNoteIcon
    BagLuggageBuggageIcon
    BagShoppingIcon
    BankIcon
    BatteryChargingIcon
    BedIcon
    BellSimpleIcon
    BirthdayCakeIcon
    BookGuideInfoFaqIcon
    BookIcon
    BookmarkBannerFlagTagIcon
    BotIcon
    BrainAiThinkingIcon
    BrowserWindowAppDesktopIcon
    BrushColorIcon
    BubbleAnnotationMessageIcon
    BucketTrashCanIcon
    BugIssueIcon
    BuildingsIcon
    CalculatorIcon
    CalendarIcon
    ChartStatisticsGraphIcon
    ChatBubbleThoughtMessageIcon
    CheckRadioCircleCheckboxCheckCheckmarkConfirmIcon
    ClickIcon
    ClockCircleTimeIcon
    CloseXCircleRemoveIcon
    CloudIcon
    CloudySunCloudsIcon
    CodeBracketsIcon
    ColorIcon
    ColorSwatchPaletteColoursIcon
    ColorsPaletteColoursIcon
    CompassBrowserSafariWebInternetIcon
    CookiesIcon
    DashboardFastIcon
    DatabaseIcon
    DeleteRemoveGarbageWasteTrashCanIcon
    DiceFourIcon
    DiskSaveIcon
    EarthGlobeWorldIcon
    EditPencilPencilPenWriteDrawIcon
    EditSmallBoxPencilPenWriteDrawIcon
    EmailEnvelopeIcon
    EmailTriagerIcon
    ErrorWarningAlertIcon
    FileDocumentCloudSyncIcon
    FileDocumentsCopyIcon
    FingerPrintTouchIdIcon
    FireFlameHotHeatIcon
    FolderOpenFileIcon
    GamepadBaseRoundControllsGameJoystickIcon
    GasIcon
    GrowthGrowLeafsIcon
    HandFingerSelectIcon
    HeadphonesSupportIcon
    HeartLikeHealthLifeFavIcon
    HomeOpenHouseIcon
    ImacComputerDeviceIcon
    ImagesPhotosPicturesShotIcon
    InboxArchiveTrayShelfIcon
    InfoCircleTooltipIcon
    KeyIcon
    KeyboardMidiKeysPianoIcon
    KeyboardUpCloseDownOpenArrowIcon
    LabIcon
    LawLegalTermsImprintBalanceIcon
    LayersCopyIcon
    LifeBuoyHelpSupportIcon
    LightBulbIdeaLightIcon
    LinkChainIcon
    LocationExploreCompassIcon
    MacbookLaptopComputerDeviceIcon
    MagicBookMagicianIcon
    MagicHatIcon
    MagicStickIcon
    MeetingSchedulerIcon
    MinusCircleRemoveIcon
    MoonStarNightIcon
    MouseIcon
    NoteCardTextIcon
    NotificationBellActivityIcon
    OpenNoteBookPadIcon
    PauseIcon
    PeopleTogetherUserAvatarGroupIcon
    PhoneDeviceIphoneMobileIcon
    PhoneTelephoneContactIcon
    PictureImageFrameIcon
    PieChartGraphChartStatisticsIcon
    PiggyBankSaveMoneyIcon
    PinLocationBookmarkIcon
    PinLocationIcon
    PinLocationMapIcon
    PlayGoIcon
    PlayIcon
    PlusCircleAddIcon
    PoopSpamIcon
    PostcardCardNewsIcon
    PrinterPrintIcon
    QuestionmarkFaqHelpQuestionaireIcon
    RainbowCloudIcon
    ReadingListGlassesSteveJobsIcon
    ReloadRefreshRepeatIcon
    RocketStartupLaunchIcon
    ScriptFaxReceiptIcon
    SearchMagnifyingGlassIcon
    ServerDataStorageIcon
    ServerStorageDataCoinsMoneyIcon
    SettingsSliderThreeIcon
    ShakaCallMeHangTenIcon
    ShieldCheckSecurityProtectionIcon
    ShieldProtectSecurityCheckIcon
    ShieldSecurityProtectionIcon
    StarFavoriteAwardIcon
    StickyNoteIcon
    StorageHddSsdIcon
    SunLightModeDayIcon
    SunsetIcon
    TagSaleIcon
    TapeIcon
    TargetArrowGoalAimIcon
    TargetZoomIcon
    ToiletPaperWipeIcon
    TruckDeliveryIcon
    UmbrellaSecurityIcon
    VideoClapperboardIcon
    VoiceIcon
    VolumeFullSpeakerLoudSoundOnMusicIcon
    WebCryptoSpaceIcon
    ZapLightningFlashIcon
}

"""
An Agent Message is how agents can send or receive information.
"""
type AgentMessage implements Node {
    id: ID!

    """
    The globally unique ID for this resource
    """
    nodeId: ID!
    owner: Identity!
}

enum AgentRequireConfirmation {
    Always
    Never
    Sometimes
}

type AgentRootFolder {
    """
    The list of Agent Definitions that are not inside any folder
    """
    agentDefinitions: [AgentDefinition!]!
}

type AgentStateNode implements Node & StateGraphNode {
    """
    The actions of the agent state
    """
    actions: [StateGraphAction!]!

    """
    The user-defined display name of the node
    """
    displayName: String

    """
    The guidelines of the agent state
    """
    guidelines: String

    """
    The unique identifier for the node
    """
    id: ID!

    """
    Whether the node is manually positioned
    """
    manuallyPositioned: Boolean!

    """
    The LLM model of the agent state
    """
    model: String!

    """
    The globally unique ID for the Agent State Node
    """
    nodeId: ID!

    """
    The position of the node
    """
    position: NodePosition!

    """
    Whether the agent state requires confirmation
    """
    requireConfirmation: AgentRequireConfirmation!

    """
    The type of the node
    """
    type: NodeType!
}

"""
An Agent Template Definition contains information about the agent's behavior and can be added by users from the marketplace
"""
type AgentTemplateDefinition implements Node {
    category: TemplateCategory

    """
    Whether or not this is an officially featured Lindy in the marketplace or not
    """
    featured: Boolean!
    icon: AgentIcon
    id: ID!

    """
    The name of the Agent Template Definition
    """
    name: String!

    """
    The globally unique ID for the Agent Template Definition
    """
    nodeId: ID!

    """
    The subtitle of the Agent Template Definition
    """
    subTitle: String
}

type Auth implements Node {
    accountId: ID!

    """
    The display name of the auth
    """
    displayName: String!

    """
    Schema for Custom Auth fields
    """
    fields: JSONObject

    """
    Whether all required scopes are satisfied
    """
    hasAllScopes: Boolean!
    id: ID!

    """
    True if this auth is valid
    """
    isConnected: Boolean!
    label: String!
    method: String!

    """
    The globally unique ID for the auth used by Relay
    """
    nodeId: ID!
    owner: Identity!
    provider: String!
    redirectUri: URL

    """
    The scopes of the auth
    """
    scopes: [String!]!

    """
    The lindies that use this auth
    """
    usedBy: [AgentDefinition!]
}

interface AuthConfig {
    """
    The method of the auth configuration
    """
    method: AuthMethod!

    """
    The provider of the auth configuration
    """
    provider: String!
}

enum AuthMethod {
    Custom
    OAuth
    Token
}

enum AuthType {
    custom
    customoauth2
    oauth2
    token
}

type BadRequestError implements Error {
    message: String!
}

type BaseError implements Error {
    message: String!
}

"""
BigNumber scalar type
"""
scalar BigNumber

enum BillingVersion {
    V2
    V3
}

input CancelIdentityEmailUpdateInput {
    id: ID!
}

type CancelIdentityEmailUpdateOutput {
    identity: Identity!
}

input ClearAgentNotificationsInput {
    """
    This is the ID of the agent
    """
    agentDefinitionId: ID!
}

type ClearAgentNotificationsOutput {
    agent: AgentDefinition!
}

input ClearConversationNotificationInput {
    """
    This is the ID of the agent the conversation belongs to
    """
    agentDefinitionId: ID!

    """
    This is the ID of the conversation
    """
    conversationId: ID!
}

type ClearConversationNotificationOutput {
    conversation: Conversation!
}

input ContinueStateGraphTestRunWithTaskInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    The list of attachments to add to this task.
    """
    attachmentIds: [ID!]

    """
    This list of edges of the state graph
    """
    edges: [StateGraphEdgeInput!]!

    """
    The list of nodes of the state graph. Keep in mind this is unrelated to Relay nodes.
    """
    nodes: [StateGraphNodeInput!]!

    """
    The ID of the test run to be updated
    """
    stateGraphTestRunId: ID

    """
    The task to be sent as a follow-up
    """
    task: String!
}

type ContinueStateGraphTestRunWithTaskOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

type Conversation implements Node {
    """
    The AgentDefinition that this conversation belongs to
    """
    agentDefinition: AgentDefinition!
    blocks(
        after: String
        before: String
        first: Int
        last: Int
    ): ConversationBlocksConnection!
    createdAt: DateTime!

    """
    This is the node ID of the entry point node that was used when the conversation started. This will not change after the conversation has started, and it may be null till the conversation actually starts.
    """
    entryPointNodeId: ID

    """
    This is true if the conversation has new messages or actions that require the user's attention.
    """
    hasNotification: Boolean!
    id: ID!

    """
    The globally unique ID for the Conversation, this can be used to retrieve the Conversation using the node resolvers
    """
    nodeId: ID!
    openChannels: [ConversationChannel!]!
    owner: Identity!
    startingTriggerRunAttempt: TriggerRunAttempt
    status: ConversationStatus!
    title: String
    updatedAt: DateTime!
}

type ConversationBlock implements Node {
    content: ConversationBlockContentInterface!
    id: ID!

    """
    The globally unique ID for the Block, this can be used to retrieve the Block using the node resolvers
    """
    nodeId: ID!
    owner: Identity!
}

type ConversationBlockContentBase implements ConversationBlockContentInterface {
    """
    This is the full block object = This is a way to access the block's properties until all block types are added as separate GQL types.
    """
    asJSON: JSONObject!
    text: String!
    type: ConversationBlockType!
}

interface ConversationBlockContentInterface {
    """
    This is the full block object = This is a way to access the block's properties until all block types are added as separate GQL types.
    """
    asJSON: JSONObject!
    text: String!
    type: ConversationBlockType!
}

enum ConversationBlockType {
    ACTION_CALL
    ACTION_NEEDED_API_TOKEN_AUTH
    ACTION_NEEDED_CUSTOM_AUTH
    ACTION_NEEDED_CUSTOM_OAUTH2
    ACTION_NEEDED_OAUTH2_AUTH
    ACTION_NEEDED_ONBOARDING
    ACTION_NEEDED_PAUSED
    ACTION_NEEDED_RAILS_ONBOARDING
    ACTION_RESULT
    ANSWER
    HINT
    INTERNAL_ACTION_CHECKPOINT
    INTERNAL_ACTION_INPUT_SUBMISSION
    INTERNAL_EXECUTION_DETAILS
    INTERNAL_EXECUTION_TRACE
    INTERNAL_FRAMEWORK_ERROR
    INTERNAL_GRAPH_TRAVERSAL
    INTERNAL_POSTHOG_SESSION_DETAILS
    KNOWLEDGE_BASE_SEARCH_RESULT
    MEDIA
    MESSAGE_RECEIVED
    MESSAGE_SENT
    SYSTEM_INSTRUCTION
    TALK
    UNSUPPORTED_CODE
    UNSUPPORTED_CODE_ERROR
    UNSUPPORTED_CODE_RESULT
    UNSUPPORTED_CODE_VARIABLES
    UNSUPPORTED_DECLARATION
    UNSUPPORTED_EXAMPLE
    UNSUPPORTED_INTERNAL_ACTION_NEEDED_CREDITS
    UNSUPPORTED_INTERNAL_CONVERSATION_PARAMS
    UNSUPPORTED_INTERNAL_EXECUTION_CHECKPOINT
    UNSUPPORTED_INTERNAL_GUIDELINES_UPDATED
    UNSUPPORTED_INTERNAL_INCOMPLETE_BLOCK
    UNSUPPORTED_INTERNAL_STREAMING
    UNSUPPORTED_MEMORY
    UNSUPPORTED_SYSTEM_PRUNING_HINT
    UNSUPPORTED_THOUGHT
    UNSUPPORTED_TYPESCRIPT
    UNSUPPORTED_USER
}

type ConversationBlocksConnection {
    edges: [ConversationBlocksConnectionEdge]!
    pageInfo: PageInfo!
}

type ConversationBlocksConnectionEdge {
    cursor: String!
    node: ConversationBlock!
}

type ConversationChannel {
    """
    Which node created this channel (if any)
    """
    createdByNodeId: ID

    """
    The ID of the channel
    """
    id: ID!

    """
    The instance key of the tool that is being used to manage the state of this channel
    """
    instanceKey: String

    """
    If this returns null, it means this channel is not going to wake up the conversation on any node. Otherwise, it's the ID of the node that will be woken up.
    """
    startingNodeId: ID

    """
    The key of the tool that is being used to manage the state of this channel
    """
    statefulToolKey: String
    tool: Tool!
    trigger: Trigger
    type: String!
}

type ConversationStarter {
    """
    The value of the conversation starter
    """
    value: String!
}

enum ConversationStatus {
    Blocked
    Cancelled
    Cancelling
    Completed
    Deleted
    Failed
    Pending
    PendingEnqueue
    PendingRestart
    Running
}

input CopyAgentInput {
    """
    This is the ID of the agent
    """
    agentDefinitionId: ID!

    """
    This is the ID of the owner of the agent
    """
    id: ID!
}

type CopyAgentOutput {
    agent: AgentDefinition!
    owner: Identity!
}

input CreateAgentFolderInput {
    """
    You can add agent definitions inside this folder while creating it to avoid having to call a separate mutation to do this
    """
    agentDefinitionIds: [ID!]

    """
    A unique identifier for this folder that is generated by the client. This will link child folders to parent folders and is done with client ID rather than folder ID to prevent race conditions since folder creation has a significant delay due to the LLM calls.
    """
    clientId: ID!

    """
    This is the ID of the owner of this resource (Identity ID)
    """
    id: ID!

    """
    The name of the folder, this is optional, as it will be automatically generated from the list of agent definitions passed. The mutation will fail if this is not provided and the list of agents is empty.
    """
    name: String

    """
    The client ID of the folder that this folder may be nested in. If null the folder will be at the root
    """
    parentClientId: ID
}

type CreateAgentFolderOutput {
    agentFolder: AgentFolder!
    owner: Identity!
}

input CreateAgentInput {
    """
    The ID of the folder to create the agent in
    """
    folderClientId: ID
    icon: AgentIconInput

    """
    This is the ID of the owner of the agent
    """
    identityId: ID!
    name: String
}

type CreateAgentOutput {
    agentDefinition: AgentDefinition!
    owner: Identity!
}

type CreateStateGraphTestRunOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

input CreateStateGraphTestRunWithActionInput {
    """
    The ID of the action node to be tested
    """
    actionNodeId: ID!

    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    This list of edges of the state graph
    """
    edges: [StateGraphEdgeInput!]!

    """
    The list of nodes of the state graph. Keep in mind this is unrelated to Relay nodes.
    """
    nodes: [StateGraphNodeInput!]!
}

type CreateStateGraphTestRunWithActionOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

input CreateStateGraphTestRunWithConversationInput {
    """
    The ID of the conversation from which the payload should be retrieved to start a new test run
    """
    conversationId: ID!
}

type CreateStateGraphTestRunWithConversationOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

input CreateStateGraphTestRunWithSyntheticTriggerPayloadInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    This list of edges of the state graph
    """
    edges: [StateGraphEdgeInput!]!

    """
    The list of nodes of the state graph. Keep in mind this is unrelated to Relay nodes.
    """
    nodes: [StateGraphNodeInput!]!

    """
    The ID of the Trigger Entry Point node to be tested
    """
    syntheticTriggerNodeId: ID!
}

type CreateStateGraphTestRunWithSyntheticTriggerPayloadOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

input CreateStateGraphTestRunWithTaskInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    The list of attachments to add to this task.
    """
    attachmentIds: [ID!]

    """
    This list of edges of the state graph
    """
    edges: [StateGraphEdgeInput!]!

    """
    The ID of the entry point node to be tested
    """
    entryPointNodeId: ID!

    """
    The list of nodes of the state graph. Keep in mind this is unrelated to Relay nodes.
    """
    nodes: [StateGraphNodeInput!]!

    """
    The task to be sent, this only works if the entry point being tested is a Conversation Entry Point
    """
    task: String!
}

type CreditsInfo {
    consumed: Int!
    creditAllocation: Int!
    creditBalance: Int!
    percentConsumed: Float!
}

type CustomAuthConfig implements AuthConfig {
    """
    The fields of the auth configuration
    """
    fields: JSONObject!

    """
    The method of the auth configuration
    """
    method: AuthMethod!

    """
    The provider of the auth configuration
    """
    provider: String!
}

type CustomOAuth2AuthConfig implements AuthConfig {
    """
    The fields of the auth configuration
    """
    fields: JSONObject!

    """
    The method of the auth configuration
    """
    method: AuthMethod!

    """
    The provider of the auth configuration
    """
    provider: String!

    """
    The scopes of the auth configuration
    """
    scopes: [String!]!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DeleteAgentFolderInput {
    agentFolderId: ID!

    """
    This is the ID of the owner of the agent folder
    """
    id: ID!
}

type DeleteAgentFolderOutput {
    owner: Identity!
}

input DeleteAgentInput {
    """
    This is the ID of the agent
    """
    agentDefinitionId: ID!

    """
    This is the ID of the owner of the agent
    """
    id: ID!
}

type DeleteAgentOutput {
    agent: AgentDefinition!
    owner: Identity!
}

input DeleteAuthInput {
    """
    The ID of the auth
    """
    authId: ID!
}

type DeleteAuthOutput {
    """
    The node ID of the deleted auth
    """
    deletedAuthNodeId: ID!
}

input DeleteConversationInput {
    conversationId: ID!
}

type DeleteConversationOutput {
    conversation: Conversation!
}

input DeleteIdentityInput {
    id: ID!
}

type DeleteIdentityOutput {
    identity: Identity!
}

input DeleteStateGraphTestRunInput {
    """
    The ID of the State Graph Test Run to be deleted
    """
    stateGraphTestRunId: ID!
}

type DeleteStateGraphTestRunOutput {
    agentDefinition: AgentDefinition!

    """
    This is the node ID (globally unique ID, used by Relay) of the StateGraph test run that got removed
    """
    deletedStateGraphTestRunNodeId: ID!
}

type DynamicLoaderDetails {
    """
    The dependencies of the dynamic loader.
    """
    dependencies: [String!]!

    """
    The description of the dynamic loader.
    """
    description: String

    """
    The display name of the dynamic loader.
    """
    displayName: String!

    """
    The field of the dynamic loader.
    """
    field: String!
    icon: DynamicLoaderIcon!

    """
    The key of the dynamic loader.
    """
    key: String!

    """
    The placeholder of the dynamic loader.
    """
    placeholder: String
}

"""
Enumeration of all dynamic loader icons
"""
enum DynamicLoaderIcon {
    GoogleSheetRow
    UNKNOWN
    UnknownIcon
}

type DynamicLoaders {
    loaders: [DynamicLoaderDetails!]!

    """
    Whether to refetch the input after loading.
    """
    refetchInputAfterLoad: Boolean!
}

enum EdgeType {
    Observe
    Standard
}

enum EntryNodeType {
    Conversation
    Trigger
}

type EntryPointConversationNode implements EntryPointNode & Node & StateGraphNode {
    """
    The conversation starters of the entry point conversation node
    """
    conversationStarters: [ConversationStarter!]!

    """
    The user-defined display name of the node
    """
    displayName: String

    """
    The type of the entry node
    """
    entryType: EntryNodeType!

    """
    The greeting message of the entry point conversation node
    """
    greetingMessage: String

    """
    The unique identifier for the node
    """
    id: ID!

    """
    Whether the node is manually positioned
    """
    manuallyPositioned: Boolean!

    """
    The globally unique ID for the Conversation Node
    """
    nodeId: ID!

    """
    The position of the node
    """
    position: NodePosition!

    """
    The type of the node
    """
    type: NodeType!
}

interface EntryPointNode {
    """
    The type of the entry node
    """
    entryType: EntryNodeType!
}

type EntryPointTriggerNode implements EntryPointNode & Node & StateGraphNode {
    """
    The auth of the trigger
    """
    auth: Auth

    """
    The auth entries available for the trigger
    """
    authList: [Auth!]!

    """
    The user-defined display name of the node
    """
    displayName: String

    """
    The type of the entry node
    """
    entryType: EntryNodeType!

    """
    The unique identifier for the node
    """
    id: ID!

    """
    Whether the node is manually positioned
    """
    manuallyPositioned: Boolean!

    """
    The globally unique ID for the Trigger Node
    """
    nodeId: ID!

    """
    The position of the node
    """
    position: NodePosition!

    """
    The trigger database object of the entry point trigger node
    """
    trigger: Trigger

    """
    The trigger definition of the entry point trigger node
    """
    triggerDefinition: TriggerDefinition

    """
    The type of the node
    """
    type: NodeType!
}

interface Error {
    message: String!
}

type Identity implements Node {
    agentDefinitions: [AgentDefinition!]!

    """
    This represents the user's agent file structure.
    """
    agentFolders: AgentFolders!
    auth(
        """
        Auth Id
        """
        authId: ID

        """
        Authentication method
        """
        method: AuthMethod

        """
        Authentication provider
        """
        provider: String
    ): [Auth!]!

    """
    The avatar URL of the user
    """
    avatar: Image
    billingInfo: SubscriptionInfo

    """
    The date the user account was created
    """
    createdAt: Date!
    currentAgentDefinition: AgentDefinition
    email: String!
    enabledFeatureFlags: [String!]!
    id: ID!

    """
    True if and only if this user is a Lindy admin
    """
    isAdmin: Boolean!

    """
    Whether this user is considered a medical scribe customer, determined by the occupation associated with this user.
    """
    isMedicalScribe: Boolean!
    name: String!

    """
    The globally unique ID for the user used by Relay
    """
    nodeId: ID!
    owner: Identity!

    """
    If user has requested an email address change, this field contains the new unconfirmed email address. It is cleared by setting to null/empty string once user verifies the new email address through the confirmation link sent to that address.
    """
    pendingEmail: String
    phone: PhoneNumber
}

type Image {
    """
    The height of the image in pixels
    """
    heightPx: Int

    """
    The URL of the image
    """
    url: String!

    """
    The width of the image in pixels
    """
    widthPx: Int
}

input InstallAgentTemplateInput {
    """
    This is the ID of the owner of the agent
    """
    identityId: ID!

    """
    The origin of the agent template
    """
    origin: AgentDefinitionOrigin

    """
    The ID of the template to create the agent from
    """
    templateId: ID!
}

type InstallAgentTemplateOutput {
    agentDefinition: AgentDefinition!
    owner: Identity!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
A JSON schema defining the structure of a JSON object
"""
scalar JSONSchema

enum KnowledgeBaseSource {
    Box
    Confluence
    Dropbox
    Freshdesk
    GitHub
    Gitbook
    Gmail
    GoogleDrive
    Intercom
    Notion
    NotionDatabase
    OneDrive
    Outlook
    RawText
    RssFeed
    S3
    Salesforce
    SharePoint
    UNKNOWN
    Unknown
    UploadedFile
    WebScrape
    Zendesk
    Zotero
}

enum KnowledgeBaseSyncStatus {
    CrawlingWebsite
    Delayed
    EvaluatingResync
    QueueForSync
    QueuedForOcr
    RateLimited
    Ready
    SyncAborted
    SyncError
    Syncing
    UNKNOWN
    Unknown
    Uploading
}

type KnowledgeSource {
    """
    The number of entries in the knowledge source
    """
    entryCount: Int!

    """
    Whether the knowledge source is enabled
    """
    isEnabled: Boolean!

    """
    The type of the member
    """
    source: KnowledgeBaseSource!

    """
    The sync status of the knowledge source
    """
    syncStatus: KnowledgeBaseSyncStatus!

    """
    The date when the sync will be completed
    """
    syncToBeCompletedBy: Date

    """
    The total file size of the knowledge source
    """
    totalFileSize: Int!

    """
    The total number of characters in the knowledge source
    """
    totalNumCharacters: Int!

    """
    The total number of embeddings in the knowledge source
    """
    totalNumEmbeddings: Int!

    """
    The total number of errors in the knowledge source
    """
    totalNumErrors: Int!

    """
    The total number of tokens in the knowledge source
    """
    totalNumTokens: Int!
}

"""
Enumeration of all available tools
"""
enum LindyTool {
    ActionNetwork
    ActiveCampaign
    Adalo
    Affinity
    AgileCrm
    Airtable
    AmazonS3
    ApiTemplateIo
    Apitable
    Approval
    Asana
    Automizy
    Autopilot
    AwsCertificateManager
    AwsComprehend
    AwsDynamoDB
    AwsElb
    AwsRekognition
    AwsS3
    AwsSes
    AwsTranscribe
    BambooHr
    Bannerbear
    Baserow
    Beeminder
    Binance
    Bitly
    Bitwarden
    Box
    Brevo
    BrightData
    BrowseAI
    Browser
    Bubble
    CalCom
    Calendar
    CalendarEvent
    Calendly
    Certopus
    Channels
    Chargebee
    Chatbots
    CircleCi
    CiscoWebex
    CitrixAdc
    Clarifai
    Clearbit
    Clickup
    Clockify
    Clockodo
    Cloudflare
    Cockpit
    Coda
    CoinGecko
    Contentful
    Contiguity
    ConvertKit
    Copper
    Cortex
    CrowdDev
    Csv
    CustomerIo
    DataMapper
    DateHelper
    Debug
    DebugInstance
    DeepL
    Deepl
    Delay
    Demio
    Dhl
    Directory
    DirectoryEntity
    Discord
    Discourse
    Disqus
    DocumentReader
    DraftEmail
    Drift
    Drip
    Dropbox
    Dropcontact
    ERPNext
    Egoi
    ElasticSecurity
    Elasticsearch
    EmailSend
    Emelia
    FacebookLeads
    FacebookPages
    Figma
    FileEntity
    FileHandler
    FileHelper
    Flow
    Freshdesk
    Freshsales
    Freshservice
    FreshworksCrm
    GSuiteAdmin
    GcloudPubsub
    GetResponse
    Ghost
    Ghostcms
    GitHub
    GitHubPullRequest
    GitRepository
    Github
    Gitlab
    Gmail
    GmailMessage
    GoToWebinar
    Google
    GoogleAds
    GoogleAnalytics
    GoogleBigQuery
    GoogleBooks
    GoogleChat
    GoogleCloudNaturalLanguage
    GoogleCloudStorage
    GoogleContacts
    GoogleDocs
    GoogleDrive
    GoogleFirebaseCloudFirestore
    GoogleForms
    GoogleMyBusiness
    GooglePeopleContacts
    GoogleSearch
    GoogleSheets
    GoogleSlides
    GoogleTasks
    GoogleTranslate
    Gotify
    Grafana
    Gravityforms
    HackerNews
    HaloPSA
    Harvest
    HelpScout
    HighLevel
    HomeAssistant
    Http
    Hubspot
    HumanticAi
    Imap
    Inbox
    InstagramBusiness
    Intercom
    InvoiceNinja
    ItemLists
    Iterable
    Jenkins
    Jira
    Jotform
    Keap
    Kimai
    Kitemaker
    KizeoForms
    KnowledgeBase
    KoBoToolbox
    Lemlist
    Lindy
    LindyAgent
    LindyAttachment
    LindyDatabaseExperimental
    LindyEmbed
    LindyMail
    LindyMailMessage
    LindyMedia
    LindyMeeting
    LindyMessenger
    LindyStateGraphBuilder
    LindyWebhook
    Linear
    LinkedIn
    ListSearch
    Llmrails
    Localai
    LoneScale
    Magento2
    Mailcheck
    Mailchimp
    MailerLite
    Mandrill
    Marketstack
    Mastodon
    MathHelper
    Matrix
    Mattermost
    Mautic
    Medium
    MessageBird
    Metabase
    MicrosoftDynamicsCrm
    MicrosoftExcel
    MicrosoftExcel365
    MicrosoftGraphSecurity
    MicrosoftOneDrive
    MicrosoftOnedrive
    MicrosoftOutlook
    MicrosoftOutlookMessage
    MicrosoftTeams
    MicrosoftToDo
    Mindee
    Misp
    Mocean
    Monday
    MondayCom
    MonicaCrm
    Msg91
    Mysql
    Nasa
    NaturalLanguage
    Netlify
    NextCloud
    Nifty
    NocoDB
    Notion
    Npm
    Ntfy
    Odoo
    Onboarding
    OnboardingV3
    OneSimpleApi
    Onfleet
    OpenAI
    OpenRouter
    Orbit
    Oura
    Paddle
    PagerDuty
    Pastebin
    Pastefy
    PayPal
    PeopleDataLabs
    Phantombuster
    PhilipsHue
    Pipedrive
    Plivo
    PostBin
    PostHog
    Postgres
    Preferences
    ProfitWell
    Pushbullet
    Pushcut
    Pushover
    Qdrant
    QuickBase
    QuickBooks
    Raindrop
    Resend
    Rocketchat
    Rss
    Rundeck
    S3
    Saastic
    Salesforce
    Salesmate
    Schedule
    ScriptTool
    SeaTable
    SecurityScorecard
    Segment
    SendGrid
    SendToChannel
    Sendfox
    Sendgrid
    Sendinblue
    Sendy
    SentryIo
    ServiceNow
    Sftp
    Shopify
    Signl4
    Simplepdf
    Slack
    SlackMessage
    Sms77
    Smtp
    Soap
    Splunk
    Spontit
    Spotify
    Square
    Ssh
    StabilityAi
    State
    Store
    Storyblok
    Strapi
    Strava
    Stripe
    Supabase
    Surveymonkey
    SyncroMsp
    Tags
    Taiga
    Talkable
    Tally
    Tapfiliate
    Task
    Telegram
    TelegramBot
    Test
    TextGeneration
    TextHelper
    TheHiveProject
    Tidycal
    Timer
    Todoist
    TravisCi
    Trello
    Twake
    Twilio
    Twist
    Twitter
    Typeform
    UI
    UnleashedSoftware
    Uplead
    UptimeRobot
    UrlScanIo
    VenafiTlsProtectCloud
    VenafiTlsProtectDatacenter
    Vero
    Vonage
    Vtex
    Wandb
    Webflow
    Wekan
    WhatsApp
    Wise
    WooCommerce
    Wordpress
    Xero
    Xml
    YouTube
    Yourls
    Zammad
    Zendesk
    ZohoCrm
    ZohoInvoice
    Zoom
    Zulip
}

type LogicNode implements Node & StateGraphNode {
    """
    The user-defined display name of the node
    """
    displayName: String

    """
    The unique identifier for the node
    """
    id: ID!

    """
    Whether the node is manually positioned
    """
    manuallyPositioned: Boolean!

    """
    The LLM model of the logic node
    """
    model: String!

    """
    The globally unique ID for the Logic Node
    """
    nodeId: ID!

    """
    The position of the node
    """
    position: NodePosition!

    """
    The type of the node
    """
    type: NodeType!
}

type Memory {
    id: ID
    isActive: Boolean!
    value: String!
}

input MemoryInput {
    id: ID

    """
    Determines whether this memory will be included into the prompt or not. Defaulting to true
    """
    isActive: Boolean
    value: String!
}

input MoveItemsToAgentFolderInput {
    """
    Setting this to null means "Move this to the root, so it has no parent folder".
    """
    agentFolderClientId: ID

    """
    The ID of the identity whose folder items are being moved
    """
    id: ID!
    items: [AgentFolderMovableItemInput!]!
}

type MoveItemsToAgentFolderOutput {
    owner: Identity!
}

type Mutation {
    cancelIdentityEmailUpdate(
        input: CancelIdentityEmailUpdateInput!
    ): MutationCancelIdentityEmailUpdateResult!
    clearAgentNotifications(
        input: ClearAgentNotificationsInput!
    ): MutationClearAgentNotificationsResult!
    clearConversationNotification(
        input: ClearConversationNotificationInput!
    ): MutationClearConversationNotificationResult!

    """
    This continues a State Graph Test Run through a follow-up task.
    This receives no ID parameter as it will always update the active test run on the given Agent Definition.
    Keep in mind that due to the immutable nature of State Graphs, this creates a new state graph and updates its reference in the Test Run document.
    If the State Graph is invalid, a StateGraphValidationError will be returned.
    """
    continueStateGraphTestRunWithTask(
        input: ContinueStateGraphTestRunWithTaskInput!
    ): MutationContinueStateGraphTestRunWithTaskResult!
    copyAgent(input: CopyAgentInput!): MutationCopyAgentResult!
    createAgent(input: CreateAgentInput!): MutationCreateAgentResult!
    createAgentFolder(
        input: CreateAgentFolderInput!
    ): MutationCreateAgentFolderResult!

    """
    Create a new State Graph Test Run from a given action node. This will always completely disable the previous conversation test run of the given agent definition (if any).
    """
    createStateGraphTestRunWithAction(
        input: CreateStateGraphTestRunWithActionInput!
    ): MutationCreateStateGraphTestRunWithActionResult!

    """
    Create a new State Graph Test Run from an existing conversation.
    This will grab the payload initially sent to start the conversation, and use it to create a _new_ conversation
    with the same payload, and then immediately start it. This is going to use the currently active state graph.
    This will always completely disable the previous conversation test run of the given agent definition (if any).
    """
    createStateGraphTestRunWithConversation(
        input: CreateStateGraphTestRunWithConversationInput!
    ): MutationCreateStateGraphTestRunWithConversationResult!

    """
    Create a new State Graph Test Run from a Trigger Entry Point node that supports synthetic payloads.
    This will always completely disable the previous conversation test run of the given agent definition (if any).
    """
    createStateGraphTestRunWithSyntheticTriggerPayload(
        input: CreateStateGraphTestRunWithSyntheticTriggerPayloadInput!
    ): MutationCreateStateGraphTestRunWithSyntheticTriggerPayloadResult!

    """
    Create a new State Graph Test Run from a given Conversation entry point node. This will always completely disable the previous conversation test run of the given agent definition (if any).
    """
    createStateGraphTestRunWithTask(
        input: CreateStateGraphTestRunWithTaskInput!
    ): MutationCreateStateGraphTestRunWithTaskResult!
    deleteAgent(input: DeleteAgentInput!): MutationDeleteAgentResult!
    deleteAgentFolder(
        input: DeleteAgentFolderInput!
    ): MutationDeleteAgentFolderResult!
    deleteAuth(input: DeleteAuthInput!): MutationDeleteAuthResult!
    deleteConversation(
        input: DeleteConversationInput!
    ): MutationDeleteConversationResult!
    deleteIdentity(input: DeleteIdentityInput!): MutationDeleteIdentityResult!

    """
    This will delete the given State Graph Test Run and ensure the triggers on the previously created conversation are disabled.
    """
    deleteStateGraphTestRunInput(
        input: DeleteStateGraphTestRunInput!
    ): MutationDeleteStateGraphTestRunInputResult!
    installAgentTemplate(
        input: InstallAgentTemplateInput!
    ): MutationInstallAgentTemplateResult!
    moveItemsToAgentFolder(
        input: MoveItemsToAgentFolderInput!
    ): MutationMoveItemsToAgentFolderResult!

    """
    Reenables a live capture trigger
    """
    reenableLiveCaptureTrigger(triggerId: ID!): Trigger!
    renameConversation(
        input: RenameConversationInput!
    ): MutationRenameConversationResult!
    replaceAgentMemories(
        input: ReplaceAgentMemoryInput!
    ): MutationReplaceAgentMemoriesResult!
    requestIdentityEmailUpdate(
        input: RequestIdentityEmailUpdateInput!
    ): MutationRequestIdentityEmailUpdateResult!
    resendIdentityEmailUpdate(
        input: ResendIdentityEmailUpdateInput!
    ): MutationResendIdentityEmailUpdateResult!

    """
    This retries a State Graph Test Run from an execution ID with the updated State Graph.
    This receives no ID parameter as it will always update the active test run on the given Agent Definition.
    Keep in mind that due to the immutable nature of State Graphs, this creates a new state graph and updates its reference in the Test Run document.
    If the State Graph is invalid, a StateGraphValidationError will be returned.
    """
    retryStateGraphTestRunExecution(
        input: RetryStateGraphTestRunExecutionInput!
    ): MutationRetryStateGraphTestRunExecutionResult!

    """
    Initializes a State Graph Test Run through a Trigger Entry Point and a Trigger Run Attempt.
    """
    selectStateGraphTestRunTriggerEntryPointPayload(
        input: SelectStateGraphTestRunTriggerEntryPointPayloadInput!
    ): MutationSelectStateGraphTestRunTriggerEntryPointPayloadResult!
    skipWakeUpTaskTrigger(
        input: SkipWakeUpTaskTriggerInput!
    ): MutationSkipWakeUpTaskTriggerResult!
    startConversationFromNode(
        input: StartConversationFromNodeInput!
    ): MutationStartConversationFromNodeResult!

    """
    This initializes a State Graph Test Run with a Live Capture trigger.
    """
    startLiveCaptureForStateGraphTestRun(
        input: StartLiveCaptureForStateGraphTestRunInput!
    ): MutationStartLiveCaptureForStateGraphTestRunResult!

    """
    This ends the current Live Capture session for a State Graph Test Run.
    """
    stopLiveCaptureForStateGraphTestRun(
        input: StopLiveCaptureForStateGraphTestRunInput!
    ): MutationStopLiveCaptureForStateGraphTestRunResult!
    updateAgent(input: UpdateAgentInput!): MutationUpdateAgentResult!
    updateAgentFolder(
        input: UpdateAgentFolderInput!
    ): MutationUpdateAgentFolderResult!
    updateCurrentAgentDefinition(
        input: UpdateCurrentAgentDefinitionInput!
    ): MutationUpdateCurrentAgentDefinitionResult!
    updateIdentity(input: UpdateIdentityInput!): MutationUpdateIdentityResult!
    updateIdentityAvatar(
        input: UpdateIdentityAvatarInput!
    ): MutationUpdateIdentityAvatarResult!
    updateIdentityPassword(
        input: UpdateIdentityPasswordInput!
    ): MutationUpdateIdentityPasswordResult!
    updateOrCreateCustomAuth(
        input: UpdateOrCreateCustomAuthInput!
    ): MutationUpdateOrCreateCustomAuthResult!
    updateOrCreateTokenAuth(
        input: UpdateOrCreateTokenAuthInput!
    ): MutationUpdateOrCreateTokenAuthResult!
}

union MutationCancelIdentityEmailUpdateResult =
      BaseError
    | MutationCancelIdentityEmailUpdateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationCancelIdentityEmailUpdateSuccess {
    data: CancelIdentityEmailUpdateOutput!
}

union MutationClearAgentNotificationsResult =
      BaseError
    | MutationClearAgentNotificationsSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationClearAgentNotificationsSuccess {
    data: ClearAgentNotificationsOutput!
}

union MutationClearConversationNotificationResult =
      BaseError
    | MutationClearConversationNotificationSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationClearConversationNotificationSuccess {
    data: ClearConversationNotificationOutput!
}

union MutationContinueStateGraphTestRunWithTaskResult =
      BaseError
    | MutationContinueStateGraphTestRunWithTaskSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationContinueStateGraphTestRunWithTaskSuccess {
    data: ContinueStateGraphTestRunWithTaskOutput!
}

union MutationCopyAgentResult =
      BaseError
    | MutationCopyAgentSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationCopyAgentSuccess {
    data: CopyAgentOutput!
}

union MutationCreateAgentFolderResult =
      BaseError
    | MutationCreateAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationCreateAgentFolderSuccess {
    data: CreateAgentFolderOutput!
}

union MutationCreateAgentResult =
      BaseError
    | MutationCreateAgentSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationCreateAgentSuccess {
    data: CreateAgentOutput!
}

union MutationCreateStateGraphTestRunWithActionResult =
      BaseError
    | MutationCreateStateGraphTestRunWithActionSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationCreateStateGraphTestRunWithActionSuccess {
    data: CreateStateGraphTestRunWithActionOutput!
}

union MutationCreateStateGraphTestRunWithConversationResult =
      BaseError
    | MutationCreateStateGraphTestRunWithConversationSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationCreateStateGraphTestRunWithConversationSuccess {
    data: CreateStateGraphTestRunWithConversationOutput!
}

union MutationCreateStateGraphTestRunWithSyntheticTriggerPayloadResult =
      BaseError
    | MutationCreateStateGraphTestRunWithSyntheticTriggerPayloadSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationCreateStateGraphTestRunWithSyntheticTriggerPayloadSuccess {
    data: CreateStateGraphTestRunWithSyntheticTriggerPayloadOutput!
}

union MutationCreateStateGraphTestRunWithTaskResult =
      BaseError
    | MutationCreateStateGraphTestRunWithTaskSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationCreateStateGraphTestRunWithTaskSuccess {
    data: CreateStateGraphTestRunOutput!
}

union MutationDeleteAgentFolderResult =
      BaseError
    | MutationDeleteAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteAgentFolderSuccess {
    data: DeleteAgentFolderOutput!
}

union MutationDeleteAgentResult =
      BaseError
    | MutationDeleteAgentSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteAgentSuccess {
    data: DeleteAgentOutput!
}

union MutationDeleteAuthResult =
      BaseError
    | MutationDeleteAuthSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteAuthSuccess {
    data: DeleteAuthOutput!
}

union MutationDeleteConversationResult =
      BaseError
    | MutationDeleteConversationSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteConversationSuccess {
    data: DeleteConversationOutput!
}

union MutationDeleteIdentityResult =
      BaseError
    | MutationDeleteIdentitySuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteIdentitySuccess {
    data: DeleteIdentityOutput!
}

union MutationDeleteStateGraphTestRunInputResult =
      BaseError
    | MutationDeleteStateGraphTestRunInputSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteStateGraphTestRunInputSuccess {
    data: DeleteStateGraphTestRunOutput!
}

union MutationInstallAgentTemplateResult =
      BaseError
    | MutationInstallAgentTemplateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationInstallAgentTemplateSuccess {
    data: InstallAgentTemplateOutput!
}

union MutationMoveItemsToAgentFolderResult =
      BaseError
    | MutationMoveItemsToAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationMoveItemsToAgentFolderSuccess {
    data: MoveItemsToAgentFolderOutput!
}

union MutationRenameConversationResult =
      BaseError
    | MutationRenameConversationSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationRenameConversationSuccess {
    data: RenameConversationOutput!
}

union MutationReplaceAgentMemoriesResult =
      BaseError
    | MutationReplaceAgentMemoriesSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationReplaceAgentMemoriesSuccess {
    data: ReplaceAgentMemoryOutput!
}

union MutationRequestIdentityEmailUpdateResult =
      BaseError
    | MutationRequestIdentityEmailUpdateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationRequestIdentityEmailUpdateSuccess {
    data: RequestIdentityEmailUpdateOutput!
}

union MutationResendIdentityEmailUpdateResult =
      BaseError
    | MutationResendIdentityEmailUpdateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationResendIdentityEmailUpdateSuccess {
    data: ResendIdentityEmailUpdateOutput!
}

union MutationRetryStateGraphTestRunExecutionResult =
      BaseError
    | MutationRetryStateGraphTestRunExecutionSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationRetryStateGraphTestRunExecutionSuccess {
    data: RetryStateGraphTestRunExecutionOutput!
}

union MutationSelectStateGraphTestRunTriggerEntryPointPayloadResult =
      BaseError
    | MutationSelectStateGraphTestRunTriggerEntryPointPayloadSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationSelectStateGraphTestRunTriggerEntryPointPayloadSuccess {
    data: SelectStateGraphTestRunTriggerEntryPointPayloadOutput!
}

union MutationSkipWakeUpTaskTriggerResult =
      BaseError
    | MutationSkipWakeUpTaskTriggerSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationSkipWakeUpTaskTriggerSuccess {
    data: SkipWakeUpTaskTriggerOutput!
}

union MutationStartConversationFromNodeResult =
      BaseError
    | MutationStartConversationFromNodeSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationStartConversationFromNodeSuccess {
    data: StartConversationFromNodeOutput!
}

union MutationStartLiveCaptureForStateGraphTestRunResult =
      BaseError
    | MutationStartLiveCaptureForStateGraphTestRunSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationStartLiveCaptureForStateGraphTestRunSuccess {
    data: StartLiveCaptureForStateGraphTestRunOutput!
}

union MutationStopLiveCaptureForStateGraphTestRunResult =
      BaseError
    | MutationStopLiveCaptureForStateGraphTestRunSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationStopLiveCaptureForStateGraphTestRunSuccess {
    data: StopLiveCaptureForStateGraphTestRunOutput!
}

union MutationUpdateAgentFolderResult =
      BaseError
    | MutationUpdateAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateAgentFolderSuccess {
    data: UpdateAgentFolderOutput!
}

union MutationUpdateAgentResult =
      BaseError
    | MutationUpdateAgentSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateAgentSuccess {
    data: UpdateAgentOutput!
}

union MutationUpdateCurrentAgentDefinitionResult =
      BaseError
    | MutationUpdateCurrentAgentDefinitionSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateCurrentAgentDefinitionSuccess {
    data: UpdateCurrentAgentDefinitionOutput!
}

union MutationUpdateIdentityAvatarResult =
      BaseError
    | MutationUpdateIdentityAvatarSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateIdentityAvatarSuccess {
    data: UpdateIdentityAvatarOutput!
}

union MutationUpdateIdentityPasswordResult =
      BaseError
    | MutationUpdateIdentityPasswordSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateIdentityPasswordSuccess {
    data: UpdateIdentityPasswordOutput!
}

union MutationUpdateIdentityResult =
      BaseError
    | MutationUpdateIdentitySuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateIdentitySuccess {
    data: UpdateIdentityOutput!
}

union MutationUpdateOrCreateCustomAuthResult =
      BaseError
    | MutationUpdateOrCreateCustomAuthSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateOrCreateCustomAuthSuccess {
    data: UpdateOrCreateCustomAuthOutput!
}

union MutationUpdateOrCreateTokenAuthResult =
      BaseError
    | MutationUpdateOrCreateTokenAuthSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateOrCreateTokenAuthSuccess {
    data: UpdateOrCreateTokenAuthOutput!
}

interface Node {
    nodeId: ID!
}

type NodePosition {
    x: Float!
    y: Float!
}

enum NodeType {
    Action
    AgentState
    EntryPoint
    Logic
}

type NotFoundError implements Error {
    entity: String!
    message: String!
}

type OAuth2AuthConfig implements AuthConfig {
    """
    The method of the auth configuration
    """
    method: AuthMethod!

    """
    The provider of the auth configuration
    """
    provider: String!

    """
    The scopes of the auth configuration
    """
    scopes: [String!]!
}

type ObservableChannel {
    """
    The stateful tool key of the observable channel
    """
    statefulToolKey: String!
}

type ObservableChannelMetadata {
    """
    The schema of messages received through this channel
    """
    agentMessageReceivedSchema: JSONObject!

    """
    The user facing label for the edge that executes immediately after the action creating this channel.
    """
    immediateEdgeLabel: String!

    """
    The user facing label for the edge that executes after this channel receives a message.
    """
    observableEdgeLabel: String!

    """
    The key of the stateful tool associated with this channel.
    """
    statefulToolKey: String!
}

type ObserveEdge implements Node & StateGraphEdge {
    """
    The ID of the node where the edge starts
    """
    from: ID!

    """
    The unique identifier for the edge
    """
    id: ID!

    """
    The Y-coordinate of the control point for curved edges
    """
    inflectionY: Float

    """
    The globally unique ID for the Observe Edge
    """
    nodeId: ID!

    """
    The ID of the node where the edge ends
    """
    to: ID!

    """
    The type of the edge
    """
    type: EdgeType!
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type PaymentFailure {
    """
    The amount due on the payment.
    """
    amount: BigNumber!

    """
    The date on which the payment failed.
    """
    date: Date!

    """
    The Orb invoice id for this payment.
    """
    invoiceId: String!
}

type PaymentInfo {
    brand: String!
    expMonth: Int!
    expYear: Int!
    last4: String!
}

"""
A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234.
"""
scalar PhoneNumber

enum PlanCadence {
    Annual
    Monthly
}

enum PlanType {
    FreeMonthly
    MedicalScribeTrial
    ProMonthly
    Trial
}

type Query {
    """
    This is only used for testing the scalars provided by this schema.
    """
    _scalars: ScalarsTest!
    _schemaExamples: SchemaExamples!
    me: Identity!
    node(id: ID!): Node
    nodes(ids: [ID!]!): [Node]!

    """
    Returns paginated lindy templates based on the query arguments
    """
    templates(
        after: String
        before: String

        """
        Returns only templates in the provided categories, can be combined with officialOnly
        """
        categories: [TemplateCategory!]
        first: Int

        """
        Returns only templates that are allowed to be used in the create lindy flow, overrides other arguments
        """
        forCreateLindyOnly: Boolean
        last: Int

        """
        Returns only official templates
        """
        officialOnly: Boolean
    ): QueryTemplatesConnection!

    """
    Returns agent definitions grouped by the provided categories
    """
    templatesByCategory(
        categories: [TemplateCategory!]
        officialOnly: Boolean
    ): [TemplatesByCategoryOutput!]!

    """
    Retrieves a paginated list of tools available for the authenticated user.
    """
    tools(
        after: String
        before: String
        first: Int
        last: Int
    ): QueryToolsConnection!
}

type QueryTemplatesConnection {
    edges: [QueryTemplatesConnectionEdge]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type QueryTemplatesConnectionEdge {
    cursor: String!
    node: AgentTemplateDefinition!
}

type QueryToolsConnection {
    edges: [QueryToolsConnectionEdge]!
    pageInfo: PageInfo!
}

type QueryToolsConnectionEdge {
    cursor: String!
    node: Tool!
}

input RenameConversationInput {
    conversationId: ID!
    title: String!
}

type RenameConversationOutput {
    conversation: Conversation!
}

input ReplaceAgentMemoryInput {
    agentDefinitionId: ID!
    memories: [MemoryInput!]!
}

type ReplaceAgentMemoryOutput {
    agent: AgentDefinition!
}

input RequestIdentityEmailUpdateInput {
    id: ID!
    newEmail: String!
    password: String!
    previousEmail: String!
}

type RequestIdentityEmailUpdateOutput {
    identity: Identity!
}

input ResendIdentityEmailUpdateInput {
    email: String!
    id: ID!
    name: String!
}

type ResendIdentityEmailUpdateOutput {
    identity: Identity!
}

input RetryStateGraphTestRunExecutionInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    This list of edges of the state graph
    """
    edges: [StateGraphEdgeInput!]!

    """
    The ID of the execution to retry.
    """
    executionId: ID!

    """
    The list of nodes of the state graph. Keep in mind this is unrelated to Relay nodes.
    """
    nodes: [StateGraphNodeInput!]!

    """
    The ID of the test run to be updated
    """
    stateGraphTestRunId: ID
}

type RetryStateGraphTestRunExecutionOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

type ScalarsTest {
    jsonObject: JSONObject
    jsonObjectList: [JSONObject!]!
}

type SchemaExamples {
    throwErrorWithErrorPlugin: SchemaExamplesThrowErrorWithErrorPluginResult!
    throwErrorWithoutErrorPlugin: String!
}

union SchemaExamplesThrowErrorWithErrorPluginResult =
      BaseError
    | NotFoundError
    | SchemaExamplesThrowErrorWithErrorPluginSuccess
    | UnauthorizedError
    | ValidationError

type SchemaExamplesThrowErrorWithErrorPluginSuccess {
    data: String!
}

input SelectStateGraphTestRunTriggerEntryPointPayloadInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    The ID of the external payload to start the test run task for
    """
    externalPayloadId: ID

    """
    The ID of the run attempt to start the test run task for
    """
    runAttemptId: ID

    """
    The ID of the test run to be updated
    """
    stateGraphTestRunId: ID
}

type SelectStateGraphTestRunTriggerEntryPointPayloadOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

input SkipWakeUpTaskTriggerInput {
    """
    This is the payload of the Trigger, if any. This will be validated against the trigger.
    """
    payload: JSON

    """
    This is the ID of the Trigger
    """
    triggerId: ID!
}

type SkipWakeUpTaskTriggerOutput {
    agentMessage: AgentMessage!
    conversation: Conversation!
    trigger: Trigger!
}

enum SpeechToTextTerms {
    English
    MultiLingual
}

type StandardEdge implements Node & StateGraphEdge {
    """
    The condition of the edge
    """
    condition: String

    """
    The ID of the node where the edge starts
    """
    from: ID!

    """
    The unique identifier for the edge
    """
    id: ID!

    """
    The Y-coordinate of the control point for curved edges
    """
    inflectionY: Float

    """
    The label of the edge
    """
    label: String

    """
    The globally unique ID for the Standard Edge
    """
    nodeId: ID!

    """
    The ID of the node where the edge ends
    """
    to: ID!

    """
    The type of the edge
    """
    type: EdgeType!
}

input StartConversationFromNodeInput {
    agentDefinitionId: ID!
    identityId: ID!
    nodeId: ID!
    timeZone: String!
}

type StartConversationFromNodeOutput {
    conversation: Conversation!
}

input StartLiveCaptureForStateGraphTestRunInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!

    """
    This list of edges of the state graph
    """
    edges: [StateGraphEdgeInput!]!

    """
    The list of nodes of the state graph. Keep in mind this is unrelated to Relay nodes.
    """
    nodes: [StateGraphNodeInput!]!

    """
    The ID of the entry point trigger node to listen to events for
    """
    triggerNodeId: String!
}

type StartLiveCaptureForStateGraphTestRunOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage

    """
    This will contain the generated live capture trigger
    """
    liveCaptureTrigger: Trigger!
    stateGraphTestRun: StateGraphTestRun!
}

"""
The State Graph contains the entities that are the foundation of a Lindy. The graph has a representation of the expected agent's behavior.
"""
type StateGraph implements Node {
    """
    The conversation entry point node if the state graph has one
    """
    conversationNode: EntryPointConversationNode

    """
    The edges of the State Graph
    """
    edges: [StateGraphEdge!]!
    id: ID!

    """
    The globally unique ID for the resource
    """
    nodeId: ID!

    """
    The nodes of the State Graph
    """
    nodes: [StateGraphNode!]!

    """
    The owner of the State Graph
    """
    owner: Identity!

    """
    The sticky notes of the State Graph
    """
    stickyNotes: [StateGraphStickyNote!]!

    """
    The version of the State Graph
    """
    version: Int!

    """
    The start nodes of the workflow
    """
    workflowStartNodes: [StateGraphNode!]!
}

type StateGraphAction {
    """
    The action details of the action
    """
    action: ActionDetails!

    """
    The action configuration of the action
    """
    actionConfiguration: [ActionConfigurationMember!]!

    """
    The ID of the node that created the action
    """
    createdByNodeId: String

    """
    The observable channel of the action
    """
    observableChannel: ObservableChannel

    """
    Whether the action requires confirmation
    """
    requireConfirmation: AgentRequireConfirmation!

    """
    The stateful tool key of the action
    """
    statefulToolKey: String

    """
    The tool of the action
    """
    tool: Tool!
}

interface StateGraphEdge {
    """
    The ID of the node where the edge starts
    """
    from: ID!

    """
    The unique identifier for the edge
    """
    id: ID!

    """
    The Y-coordinate of the control point for curved edges
    """
    inflectionY: Float

    """
    The ID of the node where the edge ends
    """
    to: ID!

    """
    The type of the edge
    """
    type: EdgeType!
}

"""
StateGraphEdge scalar type
"""
scalar StateGraphEdgeInput

enum StateGraphEntityType {
    Edge
    Graph
    Node
    StickyNote
}

enum StateGraphIssueLevel {
    Error
    Warning
}

enum StateGraphIssueType {
    Authorize
    Configure
    Reference
    Structure
    Unknown
}

interface StateGraphNode {
    """
    The user-defined display name of the node
    """
    displayName: String

    """
    The unique identifier for the node
    """
    id: ID!

    """
    Whether the node is manually positioned
    """
    manuallyPositioned: Boolean!

    """
    The position of the node
    """
    position: NodePosition!

    """
    The type of the node
    """
    type: NodeType!
}

"""
StateGraphNode scalar type
"""
scalar StateGraphNodeInput

type StateGraphStickyNote implements Node {
    """
    The unique identifier for the sticky note
    """
    id: ID!

    """
    The globally unique ID for the Sticky Note
    """
    nodeId: ID!

    """
    The content of the sticky note
    """
    note: String!

    """
    The position of the sticky note
    """
    position: StickyNotePosition!
}

type StateGraphTestRun implements Node {
    """
    This is the Conversation currently being used to test the State Graph. This can be null when the test is waiting for the initial trigger to fire, such as during Live Capturing.
    """
    conversation: Conversation
    greetingMessage: String
    id: ID!
    initiallySelectedNodeId: ID

    """
    This is the current Live Capture trigger, if it exists.
    """
    liveCaptureTrigger: Trigger

    """
    The globally unique ID used by Relay
    """
    nodeId: ID!
    owner: Identity!
}

type StateGraphValidationConfigureIssue implements StateGraphValidationIssueInterface {
    entityType: StateGraphEntityType!
    field: String!
    id: ID!
    label: String
    level: StateGraphIssueLevel!
    message: String!
    type: StateGraphIssueType!
}

type StateGraphValidationError implements Error {
    issues: [StateGraphValidationIssueInterface!]!
    message: String!
}

type StateGraphValidationIssue implements StateGraphValidationIssueInterface {
    entityType: StateGraphEntityType!
    id: ID!
    label: String
    level: StateGraphIssueLevel!
    message: String!
    type: StateGraphIssueType!
}

interface StateGraphValidationIssueInterface {
    entityType: StateGraphEntityType!
    id: ID!
    label: String
    level: StateGraphIssueLevel!
    message: String!
    type: StateGraphIssueType!
}

type StickyNotePosition {
    x: Float!
    y: Float!
}

input StopLiveCaptureForStateGraphTestRunInput {
    """
    This is the ID of the agent definition that is being tested
    """
    agentDefinitionId: ID!
}

type StopLiveCaptureForStateGraphTestRunOutput {
    agentDefinition: AgentDefinition!

    """
    This will contain the generated Agent Message (if any)
    """
    agentMessage: AgentMessage
    stateGraphTestRun: StateGraphTestRun!
}

type SubscriptionFeatures {
    arePremiumActionsEnabled: Boolean!
    arePremiumFeaturesEnabled: Boolean!
    isEligibleForFreePlan: Boolean!
    speechToText: SpeechToTextTerms
    trialCreditUsageType: TrialCreditUsageType
}

type SubscriptionInfo {
    billingPeriodEndsAt: Date
    billingPeriodStartAt: Date
    billingVersion: BillingVersion!
    creditsInfo: CreditsInfo!
    features: SubscriptionFeatures
    id: ID!

    """
    Details on last payment failure if there was one.
    """
    lastPaymentFailure: PaymentFailure
    paymentInfo: PaymentInfo

    """
    The ID of the plan in Lindy
    """
    planId: ID!

    """
    The portal/stripe URL
    """
    portal: URL
    subscriptionExpiresAt: Date

    """
    The subscription plan
    """
    subscriptionPlan: SubscriptionPlan!
    subscriptionStartAt: Date
    trialInfo: TrialInfo

    """
    The upcoming subscription plan if available
    """
    upcomingPlan: UpcomingPlan
}

type SubscriptionPlan {
    cadence: PlanCadence!
    creditAllocation: Int!
    id: ID!
    name: String!
    planType: PlanType
    price: BigNumber!
}

enum TemplateCategory {
    Emails
    Meetings
    PersonalAssistant
    SalesMarketing
    Scribe
    Support
    WorkflowAutomation
}

type TemplatesByCategoryOutput {
    category: TemplateCategory!
    featured: [AgentTemplateDefinition!]!
    templates: [AgentTemplateDefinition!]!
}

type TokenAuthConfig implements AuthConfig {
    """
    The method of the auth configuration
    """
    method: AuthMethod!

    """
    The provider of the auth configuration
    """
    provider: String!
}

type Tool implements Node {
    actions(
        after: String
        before: String
        first: Int
        last: Int
    ): ToolActionsConnection!
    description: String!
    displayName: String!
    isPopular: Boolean!
    nodeId: ID!
    tool: LindyTool!
    triggers(
        after: String
        before: String
        first: Int
        last: Int
    ): ToolTriggersConnection!
}

type ToolActionsConnection {
    edges: [ToolActionsConnectionEdge]!
    pageInfo: PageInfo!
}

type ToolActionsConnectionEdge {
    cursor: String!
    node: ActionDetails!
}

type ToolTriggerChannel {
    """
    The key of the stateful tool associated with this channel.
    """
    statefulToolKey: String!
}

type ToolTriggersConnection {
    edges: [ToolTriggersConnectionEdge]!
    pageInfo: PageInfo!
}

type ToolTriggersConnectionEdge {
    cursor: String!
    node: TriggerDefinition!
}

enum TrialCreditUsageType {
    Restricted
    Unrestricted
}

type TrialInfo {
    expiresAt: Date!
}

type Trigger implements Node {
    """
    The message to show when live capturing is active, to instruct the user on how to fire the event.
    """
    activeLiveCapturingInstructions: String!
    definition: TriggerDefinition!

    """
    Whether the trigger is enabled
    """
    enabled: Boolean!
    id: ID!

    """
    Whether the trigger is configured
    """
    isConfigured: Boolean!

    """
    Whether the trigger is pending verification
    """
    isPendingVerification: Boolean!

    """
    The globally unique ID for the resource, this can be used to fetch this resource using the node resolvers.
    """
    nodeId: ID!
    owner: Identity!

    """
    The trigger's run attempts, i.e. any time we've received a payload for this trigger, whether it was successful or not
    """
    runAttempts(
        after: String
        before: String
        first: Int
        last: Int
    ): TriggerRunAttemptsConnection!

    """
    The setup of the trigger
    """
    setup: TriggerSetup!

    """
    A list of possible payloads that can be used to test the trigger if the trigger implements the 'testingPayloads' interface
    """
    testingPayloads(
        after: String
        before: String
        first: Int
        last: Int
    ): TriggerTestingPayloadsConnection!
}

type TriggerDefinition implements Node {
    authConfig: AuthConfig

    """
    The channel of the trigger
    """
    channel: ToolTriggerChannel

    """
    The description of a trigger, to be shown in the frontend
    """
    description: String

    """
    The display name of a trigger, to be shown in the frontend
    """
    displayName: String!

    """
    The schema of the event that the trigger listens to
    """
    eventSchema: JSONObject!

    """
    To properly resolve the fields we need an Identity and [optionally] an specific Auth, this is because the fields themselves may depend on the Identity [and Auth].
    """
    fields(
        """
        This will default to the best matching auth if not provided
        """
        authId: ID

        """
        Defaults to the authenticated user
        """
        identityId: ID
    ): [TriggerFieldInterface!]!

    """
    Allows trigger configurations to be published with marketplace templates.
    """
    hasPublishableConfig: Boolean!
    id: ID!

    """
    Marks this trigger as high throughput, allowing it to run more frequently and be identified as expensive in the UI.
    """
    isHighThroughput: Boolean!

    """
    Whether the trigger is premium
    """
    isPremium: Boolean!
    name: String!
    nodeId: ID!

    """
    The schema of the raw trigger payload, as it's received from the webhook for example
    """
    payloadSchema: JSONSchema

    """
    Whether the trigger supports an empty payload
    """
    supportsEmptyPayload: Boolean!

    """
    The testing policy of the trigger
    """
    testingPolicy: TriggerTestingPolicy!

    """
    The tool of the trigger
    """
    tool: Tool!
}

type TriggerFieldCheckbox implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: Boolean
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldComparableText implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldDateTime implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: DateTime
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

interface TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldLabel implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldLindyEmbedConfig implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldLindyMail implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: String
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldLindyWebhook implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: String
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldMultiSelect implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: [String!]
    description: String
    fields: [String!]!
    hasAllowAllOption: Boolean
    id: String!
    isRequired: Boolean!
    label: String!

    """
    To properly resolve the options of this field we need an Identity and [optionally] a specific Auth, this is because fetching the options usually resolve around fetching external resources, which may depend on the Identity [and Auth].
    """
    options(
        """
        This will default to the best matching auth if not provided
        """
        authId: ID

        """
        Defaults to the authenticated user
        """
        identityId: ID
    ): [TriggerFieldOption!]!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldNumber implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: Float
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    max: Float
    min: Float
    placeholder: String
    step: Float
    tooltip: String
    type: String!
}

type TriggerFieldOption {
    id: String!
    label: String!
    value: String!
}

type TriggerFieldRecurringSchedule implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: String
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerFieldSelect implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: String
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!

    """
    To properly resolve the options of this field we need an Identity and [optionally] a specific Auth, this is because fetching the options usually resolve around fetching external resources, which may depend on the Identity [and Auth].
    """
    options(
        """
        This will default to the best matching auth if not provided
        """
        authId: ID

        """
        Defaults to the authenticated user
        """
        id: ID
    ): [TriggerFieldOption!]!
    placeholder: String
    selectFirstByDefault: Boolean
    tooltip: String
    type: String!
}

type TriggerFieldText implements TriggerFieldInterface {
    canBeSharedWithTemplate: Boolean!
    defaultValue: String
    description: String
    fields: [String!]!
    id: String!
    isRequired: Boolean!
    label: String!
    placeholder: String
    tooltip: String
    type: String!
}

type TriggerRunAttempt implements Node {
    """
    The date and time when the Trigger Run Attempt was created
    """
    createdAt: String!

    """
    The external ID of the payload that created this trigger run attempt, if it exists
    """
    createdByExternalPayloadId: String
    id: ID!
    llmSummary: String!

    """
    The globally unique ID for the Trigger Run Attempt, this can be used to retrieve the Trigger Run Attempt using the node resolvers
    """
    nodeId: ID!
    owner: Identity!
    payload: Unknown
    payloadId: ID
    processedPayload: Unknown
    shouldRunCheck: TriggerShouldRunCheck
}

type TriggerRunAttemptsConnection {
    edges: [TriggerRunAttemptsConnectionEdge]!
    pageInfo: PageInfo!
}

type TriggerRunAttemptsConnectionEdge {
    cursor: String!
    node: TriggerRunAttempt!
}

type TriggerSetup {
    actionArgs: JSONObject!
    actionName: String!

    """
    The auth of the trigger
    """
    auth: Auth
    toolName: String!
}

type TriggerShouldRunCheck {
    reasons: [TriggerShouldRunCheckReason!]
    shouldRun: Boolean!
    softFilter: Boolean
}

type TriggerShouldRunCheckReason {
    message: String!
}

type TriggerTestingPayload implements Node {
    externalId: ID!
    llmSummary: String!

    """
    The globally unique ID for the Trigger Testing Payload, this can be used to retrieve the Trigger Run Attempt using the node resolvers
    """
    nodeId: ID!
    payload: Unknown!
    shouldRunCheck: TriggerShouldRunCheck
}

type TriggerTestingPayloadsConnection {
    edges: [TriggerTestingPayloadsConnectionEdge]!
    pageInfo: PageInfo!
}

type TriggerTestingPayloadsConnectionEdge {
    cursor: String!
    node: TriggerTestingPayload!
}

type TriggerTestingPolicy {
    fullyProcessLiveCapturePayloads: Boolean!
    supportsSyntheticPayload: Boolean!
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

type UnauthorizedError implements Error {
    message: String!
}

"""
Equivalent to the `unknown` TypeScript type
"""
scalar Unknown

type UpcomingPlan {
    startDate: Date!
    subscriptionPlan: SubscriptionPlan!
}

input UpdateAgentFolderInput {
    """
    This is the ID of the agent folder
    """
    agentFolderId: ID!

    """
    This is the ID of the owner of the agent folder
    """
    id: ID!
    isExpanded: Boolean
    name: String
}

type UpdateAgentFolderOutput {
    agentFolder: AgentFolder!
    owner: Identity!
}

input UpdateAgentInput {
    """
    This is the ID of the agent
    """
    agentDefinitionId: ID!
    askForConfirmation: Boolean
    enabled: Boolean
    icon: AgentIconInput

    """
    This is the ID of the owner of the agent
    """
    id: ID!
    instructions: String
    isFavorite: Boolean
    isMuted: Boolean
    memories: [MemoryInput!]
    model: String
    name: String
}

type UpdateAgentOutput {
    agent: AgentDefinition!
}

input UpdateCurrentAgentDefinitionInput {
    agentDefinitionId: ID!
    identityId: ID!
}

type UpdateCurrentAgentDefinitionOutput {
    identity: Identity
}

input UpdateIdentityAvatarInput {
    """
    The upload data and file metadata. If null the user's avatar will be deleted
    """
    file: UploadAvatarFileInput
    id: ID!
}

type UpdateIdentityAvatarOutput {
    identity: Identity!
}

input UpdateIdentityInput {
    id: ID!
    name: String
}

type UpdateIdentityOutput {
    identity: Identity!
}

input UpdateIdentityPasswordInput {
    email: String!
    newPassword: String!
    previousPassword: String!
}

type UpdateIdentityPasswordOutput {
    identity: Identity!
}

input UpdateOrCreateCustomAuthInput {
    """
    The ID of the auth, can be omitted
    """
    authId: ID

    """
    The ID of the conversation to unblock, can be omitted
    """
    conversationId: ID

    """
    The fields of the auth
    """
    fields: JSONObject!

    """
    The provider of the auth
    """
    provider: String!
}

type UpdateOrCreateCustomAuthOutput {
    auth: Auth!
}

input UpdateOrCreateTokenAuthInput {
    """
    The ID of the auth, can be omitted
    """
    authId: ID

    """
    The ID of the conversation to unblock, can be omitted
    """
    conversationId: ID

    """
    The provider of the auth
    """
    provider: String!

    """
    The token of the auth
    """
    token: String!
}

type UpdateOrCreateTokenAuthOutput {
    auth: Auth!
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input UploadAvatarFileInput {
    heightPx: Int!
    upload: Upload!
    widthPx: Int!
}

type ValidationError implements Error {
    fieldErrors: [ValidationFieldError!]!
    message: String!
}

type ValidationFieldError {
    message: String!
    path: [String!]!
}
