//! Compatibility tests against @graphql-codegen reference output.
//!
//! Test cases are defined as JSON files in `cases/`. Each JSON specifies schema files,
//! documents, plugins, and config options. The Rust test runner generates output using
//! `Preset::GraphqlCodegen` and snapshots via insta.
//!
//! JS reference output lives in `references/` (generated by `pnpm generate`).
//! The `diff-references.sh` script compares our snapshots against JS output.

use std::collections::HashMap;
use std::path::PathBuf;

use gql_codegen_core::{
    ExtractConfig, GenerateInput, OutputConfig, PluginConfig, PluginOptions, Preset, SourceCache,
    StringOrArray, collect_documents, generate_from_input, load_schema, load_sources,
    resolve_schema_paths,
};

/// JSON test case format
#[derive(serde::Deserialize)]
struct TestCase {
    /// Test name (used for snapshot naming)
    name: String,
    /// Schema files relative to tests/fixtures/
    schema: Vec<String>,
    /// Document files relative to tests/fixtures/ (empty for schema-only)
    #[serde(default)]
    documents: Vec<String>,
    /// Plugin names to run (e.g. ["typescript"], ["typescript-operations"])
    plugins: Vec<String>,
    /// PluginOptions in camelCase (matches serde rename)
    #[serde(default)]
    config: serde_json::Value,
}

fn fixtures_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures")
}

fn run_test_case(path: &std::path::Path) {
    let json = std::fs::read_to_string(path).unwrap();
    let case: TestCase = serde_json::from_str(&json).unwrap();

    // Merge preset defaults with test-case config overrides
    let preset = Preset::GraphqlCodegen;
    let mut options = preset.default_options();
    if !case.config.is_null() {
        // Deserialize overrides, then apply non-default fields
        let overrides: PluginOptions = serde_json::from_value(case.config.clone()).unwrap();
        apply_overrides(&mut options, &overrides, &case.config);
    }

    // Load schema
    let schema_refs: Vec<&str> = case.schema.iter().map(|s| s.as_str()).collect();
    let schema = load_schema(&resolve_schema_paths(&schema_refs, Some(&fixtures_dir()))).unwrap();

    // Load documents if specified
    let mut cache = SourceCache::new();
    if !case.documents.is_empty() {
        let doc_patterns =
            StringOrArray::Multiple(case.documents.iter().map(|s| s.to_string()).collect());
        load_sources(&doc_patterns, Some(&fixtures_dir()), &mut cache).unwrap();
    }
    let docs = collect_documents(&cache, &ExtractConfig::default());

    // Build plugins list
    let plugins: Vec<PluginConfig> = case
        .plugins
        .iter()
        .map(|name| PluginConfig::Name(name.clone()))
        .collect();

    let mut generates = HashMap::new();
    generates.insert(
        "output.ts".to_string(),
        OutputConfig {
            plugins,
            config: Some(options),
            prelude: None,
            documents_only: false,
            hooks: None,
        },
    );

    let input = GenerateInput {
        schema: &schema,
        documents: &docs,
        generates: &generates,
        preset,
    };

    let result = generate_from_input(&input).unwrap();
    assert_eq!(result.files.len(), 1);
    let output = &result.files[0].content;

    insta::assert_snapshot!(case.name.clone(), output);
}

/// Apply only the fields explicitly present in the JSON config object onto
/// the preset defaults. Fields not mentioned in JSON keep their preset value.
fn apply_overrides(
    target: &mut PluginOptions,
    overrides: &PluginOptions,
    raw: &serde_json::Value,
) {
    let obj = match raw.as_object() {
        Some(o) => o,
        None => return,
    };

    // Only override fields that are explicitly present in the JSON
    if obj.contains_key("enumsAsTypes") {
        target.enums_as_types = overrides.enums_as_types;
    }
    if obj.contains_key("enumsAsConst") {
        target.enums_as_const = overrides.enums_as_const;
    }
    if obj.contains_key("futureProofEnums") {
        target.future_proof_enums = overrides.future_proof_enums;
    }
    if obj.contains_key("futureProofUnions") {
        target.future_proof_unions = overrides.future_proof_unions;
    }
    if obj.contains_key("immutableTypes") {
        target.immutable_types = overrides.immutable_types;
    }
    if obj.contains_key("skipTypename") {
        target.skip_typename = overrides.skip_typename;
    }
    if obj.contains_key("nonOptionalTypename") {
        target.non_optional_typename = overrides.non_optional_typename;
    }
    if obj.contains_key("avoidOptionals") {
        target.avoid_optionals = overrides.avoid_optionals.clone();
    }
    if obj.contains_key("noExport") {
        target.no_export = overrides.no_export;
    }
    if obj.contains_key("onlyOperationTypes") {
        target.only_operation_types = overrides.only_operation_types;
    }
    if obj.contains_key("constEnums") {
        target.const_enums = overrides.const_enums;
    }
    if obj.contains_key("useUtilityTypes") {
        target.use_utility_types = overrides.use_utility_types;
    }
    if obj.contains_key("declarationKind") {
        target.declaration_kind = overrides.declaration_kind;
    }
    if obj.contains_key("enumPrefix") {
        target.enum_prefix = overrides.enum_prefix.clone();
    }
    if obj.contains_key("enumSuffix") {
        target.enum_suffix = overrides.enum_suffix.clone();
    }
    if obj.contains_key("typesPrefix") {
        target.types_prefix = overrides.types_prefix.clone();
    }
    if obj.contains_key("typesSuffix") {
        target.types_suffix = overrides.types_suffix.clone();
    }
    if obj.contains_key("maybeValue") {
        target.maybe_value = overrides.maybe_value.clone();
    }
    if obj.contains_key("inputMaybeValue") {
        target.input_maybe_value = overrides.input_maybe_value.clone();
    }
    if obj.contains_key("scalars") {
        target.scalars = overrides.scalars.clone();
    }
    if obj.contains_key("strictScalars") {
        target.strict_scalars = overrides.strict_scalars;
    }
    if obj.contains_key("defaultScalarType") {
        target.default_scalar_type = overrides.default_scalar_type.clone();
    }
    if obj.contains_key("namingConvention") {
        target.naming_convention = overrides.naming_convention.clone();
    }
    if obj.contains_key("useTypeImports") {
        target.use_type_imports = overrides.use_type_imports;
    }
    if obj.contains_key("inlineFragments") {
        target.inline_fragments = overrides.inline_fragments;
    }
    if obj.contains_key("dedupeSelections") {
        target.dedupe_selections = overrides.dedupe_selections;
    }
}

// ── Test functions using insta::glob! ──────────────────────────────────────────

#[test]
fn compat_typescript() {
    insta::glob!("cases/typescript/*.json", |path| {
        run_test_case(path);
    });
}

#[test]
fn compat_typescript_operations() {
    insta::glob!("cases/typescript-operations/*.json", |path| {
        run_test_case(path);
    });
}
